# Drag and Drop with AppRun

## Learning Objectives
TODO

## Pre-requisites
TODO

## Lesson

### Dragging

When you start dragging an event is triggered. We want to intercept this event and keep track of which element is being dragged.

```javascript
`<li id="${task.id}" draggable="true" ondragstart="app.run('ondragstart', event)">`
```
Make the `task.id` the id of the HTML element. Add the update function `onDragStart`. Notice we are going to pass in the event object.
```javascript
    onDragStart: (state, event) => {
        event.dataTransfer.setData('text', event.target.id)
        return state
    }
```
When we start dragging we set the drag event up to transfer some data, the id of the task being dragged. Can you see how we read the id of the element being dragged from the `event` object and in particular the `event.target` object.

### Dropping

Lets make it so if you drag a task from the list it will delete it. For that we need to detect the drop event, and we need to make a drop zone. Can you put another element next to your list? Get them to sit next to each other on the page.

![flexbox example](https://user-images.githubusercontent.com/4499581/95676057-55b66380-0bb3-11eb-97ef-be07d2948bd5.png)

The hotpink section is the drop zone. HTML elements by default are NOT droppable. To make a drop zone, we need to override the default behavior of the browser. To do this you will have to add a `ondragover` event listener to your drop zone element. You can also add the `ondrop` event listener, and add the event handler to `ondrop`.

```html
<div ondragover="event.preventDefault()" ondrop="app.run('onDrop', event)"></div>
```

Here we are calling `event.preventDefault()` whenever an element is dragged over this element. By doing this we will enable dropping on that element. Then we add our `ondrop` event handler and capture the drop event. We need the `event` object from the drop to get the data values we passed from the dragging element.

Delete the item from the array in `state.tasks`.

```javascript
onDrop: (state, event) => {
    event.preventDefault()
    const id = event.dataTransfer.getData('text')
    const index = state.tasks.findIndex(task => task.id == id)
    state.tasks.splice(index, 1)
    return state
}
```

### stopPropagation

What happens if we have nested drop zones? For now imagine I want to either 'highlight' a task or delete it.

![nested drop zones](https://user-images.githubusercontent.com/4499581/95676910-ba74bc80-0bb9-11eb-9f7e-e448e3888812.png)

I'm going to add a different update function that will add a 'highlight' class to my task. The behavior I am looking for is when I drag and drop on the highlight zone, my task should become highlighted. However! It doesn't work. My task just gets deleted. Why is that?

The drop event will cause <u>BOTH</u> event handlers to be triggered; `onDrop` and my `onHighlight`. The event propagates up through the DOM. This behavior is called bubbling. I don't want this. When the `ondrop` listener triggers my `onHighlight` event handler I want the event propagation to stop. I will have to call `event.stopPropagation()` to stop the event triggering other event handlers.

```javascript
onHighlight: (state, event) => {
    event.preventDefault()
    event.stopPropagation()
    const id = event.dataTransfer.getData('text')
    const index = state.tasks.findIndex(task => task.id === id)
    state.tasks[index].highlight = 'highlight'
    return state
}
```

![highlight task now works thanks to stop propagation](https://user-images.githubusercontent.com/4499581/95677015-9bc2f580-0bba-11eb-8894-8657e1a852f0.png)

### Summary

There are some important concepts we have looked at in this lesson. First of all we have learnt more about the event object. We have seen how it can be used to:

* transfer data
* override default browser behaviors
* stop event propagation

## Assignment

* Implement drag and drop to delete a task in your todo app

### Assignment extension tasks

## Additional resources
