# AJAX (Asynchronous JavaScript And XML)

## Learning Objectives

* Explain what AJAX means
* Understand what makes a single page app (SPA)
* Use `XMLHTTPRequest` and `fetch`

## Pre-requisites
TODO
* You will need your todo app
* You will need to create an express server

## Lesson

!(https://docs.google.com/presentation/d/e/2PACX-1vT4wCJjWXLsTFfoX-0JzvXu4bNZa-wDE2QfXAn5cOrYhchUekDfDw52QSR_FSfHSeAzCD7aQbokFW4t/embed)

The AJAX pattern lead to a different kind of web site. A site that was closer to an app, one HTML page is loaded, then the following pages and interactions are all driven by JavaScript. It is this pattern that we are going to implement in our group projects. To follow along we'll make a simple server that will store our tasks.

### Create our data server

This express server will server our single HTML page, and then all consequential requests will be for the data it needs to run. Create a `server.js` file in your project folder. Create a `public` folder and put your `index.html`, `style.css` and `main.js` in that folder. Set express up to serve static assets from the `public` folder, and deal with json requests, finally run your server on port 3000.

```javascript
const express = require('express')
const app = express()

app.use(express.static('public'))
app.use(express.urlencoded({ extended: true }))
app.use(express.json())

const tasks = [
    {
        id: 1,
        text: 'Fetch all the tasks',
        status: 0
    },
    {
        id: 2,
        text: 'Create a new task',
        status: 0
    }
]

app.listen(3000, () => {
    console.log('app server running on port', 3000)
})
```
I have added some tasks on the server. Our first job will be to fetch these once the page has loaded.

### Making AJAX requests

We are going to use the `fetch` API that comes bundled in the javascript runtime in the browser. We need an update function in our AppRun update object that is going to get all the tasks on the server.

```javascript
    getTasks: async (state) => {
        state.tasks = await fetch('/tasks').then(res => res.json())
        return state
    }
```
What kind of function is getTasks? We can make a simple 'get' request using `fetch` it uses the `Promise` object. `fetch` will return an HTTP response object, we then need to transform that into usable JSON. In the example above we can expect the `/tasks` endpoint to return an Array of tasks. We assign that into state and that will trigger a re-render.

On the server we can add the `/tasks` endpoint:

```javascript
app.get('/tasks', (req, res) => {
    res.send(tasks)
})
```

The key take away here is - no templates. We don't do templating on the server, we just respond with the data our single page app needs. The next refactor is to create a task on the server, not just on the frontend. Update your `add` update function, don't push the new task into `state.tasks`. Instead post it to the server, and then trigger `app.run('getTasks')`.

```javascript
    add: (state, form) => {
        const data = new FormData(form)
        const task = {
            id: window.crypto.getRandomValues(new Uint8Array(2)).join(''),
            text: data.get('text'),
            highlight: '',
            status: 0
        }
        const postRequest = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(task)
        }
        fetch('/tasks', postRequest).then(() => app.run('getTasks'))
        return state
    },
```
Making a POST request is similar to a GET request, only now we include a javascript object with the settings for;

* method - "POST"
* headers - we have to set the type of content we are posting in the header of the request
* body - this must be a string, it is where we put our data we want to send to the server

On the server we can create an endpoint to receive the `postRequest`;

```javascript
app.post('/tasks', (req, res) => {
    tasks.push(req.body)
    res.send()
})
```
here we reply with `res.send()` on the frontend we are waiting for this, we can then make a request for the updated tasks by calling `app.run('getTasks')`. This is a design choice to demonstrate how one AppRun update function can call another update function, like a chain of events. You could return all the tasks from the POST request above, and then update the state with the new task list all within the 'add' update function.

## Assignment
* Set up an app server for yourself
* Make AJAX GET requests using `fetch`
* Make AJAX POST requests using `fetch`

## Assignment extension tasks

## Additional resources