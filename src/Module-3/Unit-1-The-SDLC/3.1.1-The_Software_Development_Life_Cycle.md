# The Software Development Life Cycle

## Learning Objectives
TODO

## Lesson
The purpose of the software development life cycle (SDLC) is to specify a set of steps which guide us in translating business requirements into operational IT systems.

The 7 stages of the SDLC are listed below.

TODO - add

|**Stage**|**Purpose**|
|---------|-----------|
|Feasibility Study|Determine if the project is worthwhile|
|Requirements Analysis|Obtain the user requirements|
|Design|Design the system|
|Development|Write the code|
|Testing|Test the software|
|Deployment|Deploy the software|
|Maintenance|Support the software|

We will discuss each stage in more detail later.

!(https://www.youtube.com/embed/i-QyW8D3ei0)

### Feasibility
A feasibility study evaluates a project's potential for success. 

The idea for a project can come from a number of different places.

*   Market forces from competitors
*   New technologies
*   Changes in regulations
*   Identifying a gap in the market

For example modern banking apps like Monzo and Starling introduced the ability to freeze a debit card from an app. Other banks saw this and reacted to the competition by implementing this same feature for their own customers. This is an example of a SDLC being driven by business needs.

A feasibility study considers the following:
* Business feasibility e.g.
   * can we get the project out ahead of our competitors?
   * does the project fit with our organisational culture/goals?
* Technical feasibility e.g.
   * do we have suitably skilled developers?
   * do we have infrastructure to support the rollout?
* Financial feasibility e.g.
   * can the project be done within budget?
   * will there be an acceptable return on investment?

Here is an example [Esports Feasibility Report](https://www.hereeast.com/documents/18/HEREEAST-210125_Esports_Feasibility_Report_Final.pdf) which discusses the use of the Queen Elizabeth Olympic Park in London as a venue for supporting the growth in the gaming industry.

> Listen up to point 2:10 of this Dragon's Den pitch. Do you think the idea is feasible?! 
!(https://www.youtube.com/embed/nf4zNLxJZnY)

Once the Feasibility Study is complete, a Business Case document is produced after the which details the justification for undertaking the project including costs, risks and benefits. 

Here is an example [Business Case for Heathrow Airport North West Runway](https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/374664/evidence-base-heathrow-north-west-final.pdf).

### Requirements Analysis
This stage of the SDLC is about working out exactly what needs to be built or purchased in order to deliver the business impacts and benefits defined in the feasibility stage. 

In Module 1 - Unit 1, we discussed how requirements are gathered, what makes a good requirement and the difference between Functional and Non-Functional requirements.  

Functional requirements can be expressed in a number of different forms including: 
* _UML Use Case_ diagrams which show the interactions between the Actors and the system

 ![So Fresh simple Use Case diagram](https://user-images.githubusercontent.com/1316724/141853327-9226b72b-71d2-49c3-af37-ca6879c05297.png)

 * _UML Activity_ diagrams which show how activities are co-ordinated

 ![Activity diagram](https://user-images.githubusercontent.com/1316724/141858901-75fae65d-d564-41a8-980a-d2ec312f56c8.png)
 * _Personas_ - ficticious characters which represent the different types of actors that will use a product
 ![Example Persona of an ex rockstar who requires high quality ingredients for his new hobby of cooking](https://user-images.githubusercontent.com/1316724/141855403-c77baa84-1777-4a53-99b9-c87a667b2cef.PNG)
* _User Stories_ which describe a feature from the perspective of the end user
 ![userStories](https://user-images.githubusercontent.com/1316724/141854008-95a7e86a-7565-41e2-89a4-33228987669e.PNG)

### Design

The purpose of the Design stage is to formulate a solution or software specification to realise the system's requirements. The chosen design is elaborated in sufficient detail to to allow developers to implement it.

The system designer/architect will be constrained by the non-functional requirements of the system such as:
* budget
* timescales
* performance requirements
* requirements for using specific technologies
* security requirements

They will also be affected by the quality of requirements and the availability of stakeholders for clarification of requirements.

Let's look at some architectures from companies using Amazon Web Services (AWS) components. Listen closely to how non-functional requirements impact how the architecture is designed.

!(https://www.youtube.com/embed/h0VJBi8eCYA)

!(https://www.youtube.com/embed/cRxvZBIa-gI)

We can use a _UML Component Diagram_ to represent architectural components, e.g. https://dzone.com/articles/solution-architecture-vs-software-architecture

Here is a very simplified architecture diagram created using a UML Component Diagrams for our SoFresh system. 

![componentDiagram](https://user-images.githubusercontent.com/1316724/141865154-26e469bc-6681-4072-90e9-efefb61a2e37.png)

We can then drill down into more detail by modelling the classes involved in the system and representing them using a _UML Class diagram_ and then using a _UML Sequence diagram_ to show the interactions between them.

![UML Class diagram](https://user-images.githubusercontent.com/1316724/142079800-2ecdd1a0-a244-4187-b735-22f1077a5276.png)

![UML Sequence diagram](https://user-images.githubusercontent.com/1316724/142079993-330edb60-175b-428e-b8ae-46dacf1fcf5e.png)

We can use an [Entity-Relationship Diagram (ERD)](https://www.lucidchart.com/pages/er-diagrams) to model relationships between database tables. 

#### Use case diagrams

Use case diagrams are a way to express all these inputs and outputs. These diagrams can help designers to express their input output design.

!(https://www.youtube.com/embed/fqFJcX6F43M)

![use case diagram](https://user-images.githubusercontent.com/4499581/75772283-8ee84480-5d43-11ea-9c95-defd5db09005.jpg)

In the rectangle are the requirements. Around the rectangle are different types of users who either provide inputs or consume outputs. What is interesting about the diagram are the places when the line from a user to a requirement crosses the edge of the rectangle. These intersections are the places that need input output design.

Considering the diagram above can you describe one of the forms that you might need to design? Include in your description the kinds of data your form would have to collect and what might happen to that data.

#### Process Design

To realise requirements sometimes you need to combine a series of processes together. This is process design. Following on from our order system we have just been looking at:

![process diagram](https://user-images.githubusercontent.com/4499581/75778926-9feb8280-5d50-11ea-8179-519a861ecf95.jpg)

In this example the website is a simple static site hosted on [surge](https://surge.sh), the organisation runs its own bespoke accounting software solution on its own servers. The databases are hosted on AWS (amazon web services) and exposed via a RESTful API. Authentication of http requests is done via a dedicated service which is also hosted on AWS.

To place an order this is the process.

1.  A user requests the website hosted on surge
2.  Surge responds with the website index page
3.  From the website a request with items to order is sent to an Auth service on AWS
4.  That Auth service validates the request then forwards the order onto the API
5.  The API processes the order by reading and writing to the databases
6.  The API responds to the request with a status

A user will be free to select items. Then they will be able to place an order. If they are logged in and have an active session then we will create an Order record, and update the Users orders collection.

##### High level to lower level

Our process design at the moment is quite high level, we can now go into more and more detail as we design the system in more and more detail.

![fractal](https://media.giphy.com/media/5MHFuFtdsKENi/giphy.gif)

For example in the diagram above we have an Authentication step in our process. That might need a more detailed design. Below is an activity diagram that shows how to handle incoming requests.

![activity diagram](https://user-images.githubusercontent.com/4499581/75785433-a16e7800-5d5b-11ea-9edc-405fb8d53d29.jpg)

##### Data

Next we might want to start thinking about our data structures. In OO (object orientated) programming our data structures are mirrored in code and in the datastore. For example our program might have an **Order** class that we interact with in our program, and each instance of an **Order** is also persisted as a row in a datastore.

Data design starts with the requirements. Once it is clear what needs to be persisted often data is then **_normalised_**.

###### Normalisation

This is a technique in data design. The aim is redundancy-free data structures. That means data structures

*   do not contain data that can be derived
*   only contain one copy of each logical point
*   contain the very latest value for each data item
*   combine items into logical groups based on underlying data dependencies.

A good example of normalisation is the way we can store a one-to-many relationship in a relational database. For example our Customers will have many orders. To normalize that data structure we should store the Customer once. Then use their id in the Orders table to create that relationship.

#### Security and control design

These are the mechanisms we design to ensure the system has integrity. The safeguards we introduce for the inputs and outputs of our system. For example; validating inputs from the user. Restricting write access to certain tables. Restricting read access for certain users.

![ordering system](https://user-images.githubusercontent.com/4499581/75792946-9240f780-5d66-11ea-9183-389a2758c527.jpg)

The outputs of the design stage might be:

*   Use Case diagrams
*   Process diagrams
*   Data models
*   Class diagrams
*   Control flow diagrams
*   UI/Component/Form designs

### Development

The input to the development stage is designs. These are then implemented by developers who encode the designs. The output of this stage is new software or updated or adapted software.

### Testing

The input to this stage is new software. We are going to go into more detail about testing in Unit 2. In brief the purpose of testing software is to remove

* Errors
* Defects
* Failures

Errors caused by code that is incorrectly implemented. Defects caused by code that works, but does not work in the way it is intended too. Failures cause your software to stop working all together. Testing should be removing these three things from your software.

The output of this stage is tested software.

### Deployment

The input to this stage is tested software. The purpose of the deployment stage is to make new software operational. This is achieved through the transfer of the tested software modules to the operational or **live** environment, along with setting up of the data required for the new system.

As with the requirements stage, below is a table of common roles and responsibilities for people operating in this stage of the SDLC.

|Role|Responsibility|
|:---|:-------------|
Service Manager|Understands impact on service levels, timings, communications
Users|Help to identify training needs. Can advise about best way to transition
Sponsor|Green lights the deployment having weighed up the impacts on business
Business Analysts|Can carry out training. Can advice on business processes to manage impact. Can ensure documentation is available
Technical Specialists|What order to technically do things in.Best methods to actually deal with data migrations.Early life support (developers, tech support)

#### 4 different ways to deploy software

##### The Big Bang

![the big bang method](https://user-images.githubusercontent.com/4499581/79762545-ce321b00-831a-11ea-8bcf-afc8b7de864a.png)

|Pros|Cons|
|:---|:---|
<ul><li>Clean break</li><li>Everyone start with new system together</li><li>Usually less expensive</li></ul>|<ul><li>High risk if failure</li><li>No going back point fix forward only</li><li>Unanticipated effects</li></ul>

##### Parallel Running

![parallel running two systems](https://user-images.githubusercontent.com/4499581/79762570-d2f6cf00-831a-11ea-8711-10dfdd721133.png)

|Pros|Cons|
|:---|:---|
<ul><li>Less risk, old system still operates</li><li>Transition users gradually or in phases</li><li>Can validate operations through comparisons</li></ul>|<ul><li>Expensive (have to maintain two systems)</li><li>More complex sharing state across two systems</li><li>Users may not use new system</li></ul>

##### Pilots

![run pilots](https://user-images.githubusercontent.com/4499581/79762573-d427fc00-831a-11ea-823f-0801de8879aa.png)

|Pros|Cons|
|:---|:---|
<ul><li>Trials/pilots to identify potential issues</li><li>Can eliminate problems before full scale deployment</li><li>Can use feedback from pilot to improve the product</li><li>Catching errors early is cheaper and more efficient</li></ul>|<ul><li>Can‚Äôt find problems at scale because it is not at scale</li><li>More complex sharing state across two systems</li><li>Pilot software likely to be different to final release</li></ul>

##### Feature releases

![feature releases](https://user-images.githubusercontent.com/4499581/79762578-d5592900-831a-11ea-9217-76259c1d1411.png)

|Pros|Cons|
|:---|:---|
<ul><li>High priority requirements delivered sooner</li><li>Introduce complexity gradually</li><li>Users can learn at a steady pace</li><li>Can fall back to previous version (without new feature) if there are problems</li></ul>|<ul><li>Users may lose interest in limited early version</li><li>Users may not like new features being regularly introduced</li><li>Users may not use new features sticking to original limited work flows</li></ul>

#### Traceability

A traceability matrix keeps track of the relationship between a requirement and its artefacts (test, code, deployment, version). This way features can be tracked across teams, throughout the SDLC.

![trace](https://user-images.githubusercontent.com/4499581/79765580-b52b6900-831e-11ea-94fd-bea5ea75db17.png)

#### Semantic Versioning (Semver)

Semver is a naming convention for versioning software. Its make of three components:

## 10.13.6

**10** is the Major version  
**13** is the Minor version  
**6** is the patch number

To progress the Major version you would expect breaking changes. Minor version increments indicate NEW features, new functionality, but no breaking changes. The patch number indicates fixes and improvements, nothing new in features or functionality.

# üë©‚Äçüíªüßë‚Äçüíª

What is the semantic version of your operating system? If you have a Windows computer Microsoft has stopped using sermver in favour of build numbers, try your version of Android or iOS.

The output of the implementation phase is operational software.

### Maintenance

What now? We have live software in production that is addressing a business need. If only that were it! But things change:

*   New user requirements
*   Market forces shift
*   Problems, bugs, incidents
*   Regulatory changes
*   Platform changes

The input to the maintenance phase is production software. This phase mainly deals with:

*   Major enhancements
*   Minor enhancements
*   Error corrections
*   Bug fixes
*   Performance improvements
*   Routine updates and upgrades

## 1st, 2nd, 3rd line support

One aspect of this phase of the SDLC is support. This can take the form of either 1st, 2nd or 3rd line support. Often this kind of support is managed by a system. Let us have a look at how it works.

### 1st line support

Usually a first point of contact when a bug or error is detected. This might be over the phone for example. Often this involves raising a ticket on a system so that your reported incident can be tracked. There may be quick solutions offered for example:

> ‚Äúhave you tried turning it off and on again?‚Äù

### 2nd line support

This is usually more involved and often a support professional with domain knowledge will try to solve the problem. This typically involves on-site visits or remote sessions. 2nd line support technicians might escalate a something they are unable to fix to 3rd line support.

### 3rd line support

This level involves the experts. These are the people who actually wrote the software or the network engineers who actually installed a network.

# When things go wrong

It happens. Sometimes software breaks in production.

!(https://www.youtube.com/embed/nmjDwNe0BcE)

Bad. However RBS was able to find what caused the problem. The output of the maintenance stage is operational software that is delivering the business aims in a sustainable way. This is also the output of the SDLC.

## Assignment

Read and study this page until you are able to:

* List the stages of the SDLC (Create Slido Quiz? or Applied Quiz)
* Name the inputs and outputs of each stage of the SDLC
* Summaries the main activity of each state of the SDLC
